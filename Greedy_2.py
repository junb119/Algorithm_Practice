'''
## 큰 수의 법칙
다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더해 가장 큰 수를 만든다.
단, 배열의 특정 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없다.

예를 들어
순서대로 2,4,5,4,6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라 가정하자.
이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 
6 + 6 + 6 + 5 + 6 + 6 + 6 + 5 인 46이 된다.
단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.
예를 들어
순서대로 3, 4, 4, 4, 4으로 이루어진 배열이 있을 때 M이 7이고 , K가 2라고 가정하자. 
이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다.
결과적으로 4 + 4 + 4 + 4 + 4 + 4 + 4인 28이 도출된다.

배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 큰 수의 법칙에 따른 결과를 출력해라


입력조건:
- 첫째 줄에 N(2 <= N <= 1,000), M( 1 <= M <= 10,000), K(1 <= K <= 10,000)의 자연수가 주어지며, 
각 자연수는 공백으로 구분한다.)

- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 
단, 각각의 자연수는 1이상 10,000이하의 수로 주어진다.

- 입력으로 주어지는 K는 항상 M보다 작거나 같다.

출력 조건:
- 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

'''

n, m ,k = map(int, input().split())

data = list(map(int, input().split()))

import time

s_time = time.time()


data.sort()
first = data[n - 1]
second = data[n - 2]
sum = 0
#0 1 2 3 4 5 6 7
1 % 3
2 % 3
3 % 3
for i in range(1, m+1) :
    if m == 0 :
        break
    if i % (k+1) == 0:
        print(second, '+', end=' ')
        sum += second
    else:
        print(first, '+', end=' ')
        sum += first
# 0 1 2 3 4 5 6 7
        
print(f'={sum}')


    
e_time = time.time()
print(f'소요시간 : {e_time-s_time}')